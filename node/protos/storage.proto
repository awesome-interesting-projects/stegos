syntax = "proto3";
package stegos.storage;

import "crypto.proto";
import "blockchain.proto";

message LSN {
    uint64 epoch = 1;
    uint32 offset = 2;
}

message MacroBlockOutputKey {
    uint64 epoch = 1;
    uint32 output_id = 2;
}

message MicroBlockOutputKey {
    uint64 epoch = 1;
    uint32 offset = 2;
    uint32 tx_id = 3;
    uint32 txout_id = 4;
}

message OutputKey {
    oneof key {
        MacroBlockOutputKey macro_block = 1;
        MicroBlockOutputKey micro_block = 2;
    }
}

message EscrowKey {
    stegos.crypto.SecurePublicKey validator_pkey = 1;
    stegos.crypto.Hash output_hash = 2;
}

message EscrowValue {
    stegos.crypto.PublicKey account_pkey = 1;
    uint64 active_until_epoch = 2;
    int64 amount = 3;
}

message Balance {
    stegos.crypto.Pt created = 1;
    stegos.crypto.Pt burned = 2;
    stegos.crypto.Fr gamma = 3;
    int64 block_reward = 4;
}

message ValidatorKeyInfo {
    stegos.crypto.SecurePublicKey network_pkey = 1;
    stegos.crypto.PublicKey account_pkey = 2;
    int64 slots = 3;
}

message PayoutInfo {
    stegos.crypto.PublicKey recipient = 1;
    int64 amount = 2;
}

message Active {}

message Failed {
    uint64 epoch = 1;
    uint32 offset = 2;
}

message ValidatorAwardState {
    stegos.crypto.PublicKey key = 1;
    oneof enum_value {
        Active active = 2;
        Failed failed = 3;
    }
}

message Awards {
    int64 budget = 1;
    uint64 difficulty = 2;
    repeated ValidatorAwardState validators_activity = 3;
}

message AwardsInfo {
    Awards service_award_state = 1;
    PayoutInfo payout = 2;
}

message EpochInfo {
    repeated ValidatorKeyInfo validators = 1;
    stegos.crypto.SecurePublicKey facilitator = 2;
    AwardsInfo awards = 3;
}

message ElectionResult {
    stegos.crypto.VRF random = 1;
    uint32 view_change = 2;
    repeated stegos.blockchain.Staker stakers = 3;
    stegos.crypto.SecurePublicKey facilitator = 4;
}
